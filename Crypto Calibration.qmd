---
title: "Crypto Calibration"
format: html
editor: visual
execute:
  echo: false
  message: false
  warning: false
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
#| labels: initial setup
#| results: false
library(ggplot2)
library(tidyverse)
library(ggiraph)
library(patchwork)
library(fitdistrplus) # <- required for t.scaled/normal distribution
library(metRology) # <- required for t.scaled distribution
library(GeneralizedHyperbolic) # <- required for hyperb distribution
library(VarianceGamma) # <- required for vg distribution

data_folder <- "./Data"

source("./plot_open_over_time.R")
source("./plot_empirical_returns.R")
source("./distribution_functions.R")
source("./extract_fitting_statistics.R")
source("./create_tabset.R")


risk_premium <- 0.03

crypto_colours <- c("BTC" = "#f7931a", "ETH" = "#116797", "XRP" = "#2f2c56", "DGE" = "#987F50")
crypto_levels <- names(crypto_colours)
crypto_files <- paste0(data_folder, "/", crypto_levels, " Historical Data.csv")

date_ceiling <- as.Date("2025-05-01")
date_floor <- as.Date("2012-01-01")

# =================================================
# ============== Clean market data ================
# =================================================
market_data <-
  crypto_files |>
  map(\(x) read_csv(x, col_types = c(Date = "c", Open = "n", `Vol.` = "c"))) |>
  setNames(crypto_levels) |>
  map(\(x) dplyr::select(x, Date, Open, Vol.)) |>
  bind_rows(.id = "crypto") |>
  mutate(Date = as.Date(Date, tryFormats = c("%d/%m/%Y"))) |>
  janitor::clean_names() |>
  dplyr::mutate(crypto = factor(crypto, levels = crypto_levels)) |>
  dplyr::filter(date <= date_ceiling,
                date >= date_floor) |>
  arrange(crypto, date) |>
  mutate(simple_returns_raw = dplyr::if_else(crypto == lag(crypto, 12), (open / lag(open, 12)) - 1, NA)) |>
  mutate(simple_returns_neutral = (1 + simple_returns_raw) * (1 + risk_premium) / mean(1 + simple_returns_raw, na.rm = TRUE) - 1, .by = crypto) |>
  mutate(log_returns = log(1 + simple_returns_neutral))

# =================================================
# ============== Fit distributions ================
# =================================================

distributions = c(
  "Normal" = "norm", 
  "Logistic" = "logis", 
  "Student T" = "t.scaled", 
  "Hyperbolic" = "hyperb", 
  "Variance-Gamma" = "vg"
  )

fitted_distributions <-
  market_data |>
  dplyr::summarise(
    data = list(log_returns |> na.omit()),
    .by = crypto
  ) |>
  tidyr::expand_grid(distribution = unname(distributions)) |>
  dplyr::mutate(
    model = purrr::map2(
      .x = distribution,
      .y = data,
      .f = function(x, y) fit_distribution(x, c(unlist(y)))
    )
  ) |>
  dplyr::mutate(
    data_percentiles = purrr::map(data, .f = extract_data_percentiles)
  ) |> 
  dplyr::mutate(
    fitted_quantiles = 
      dplyr::pick(distribution, model, data_percentiles) |> 
      dplyr::rename(percentiles = data_percentiles) |> 
      purrr::pmap(.f = extract_fit_quantiles)
  )

```

## The Premise

Hypothetical... you are the chief actuary of a major insurance company. You have invested significantly in the cryptocurrency markets. The regulator has requested to view your internal model calibration for this risk exposure, however in all the excitement of "hodling" you forgot to write one. What do you do!?

Worry no more. The following article considers an approach for an internal model calibration of cryptocurrency risk. And is available to use free of charge.

Disclaimer: This article is absolutely **NOT** an endorsement of cryptocurrency as an asset class. This calibration is also unlikely to get you out of trouble with the regulator.

## Data Used

### Source

Index data was taken from a publicly available source: https://www.investing.com/. We have selected the data for value in GBP of the three of the largest cryptocurrencies by market capitalisation: Bitcoin (BTC), Ethereum (ETH) and Ripple (XRP).

We have used data as far back as available, capped to 2012. This represents different start dates for different cryptocurrencies. We have:

Jan-12 for BTC Feb-15 for XRP Apr-16 for ETH

The data used is up until May-25, which was the latest available month at time of writing.

We performed an array of stationarity tests on the Bitcoin dataset. In all cases p-values were above 0.05, meaning we could not reject any of the null hypotheses. This was both in tests where the null hypothesis was the data contains a trend, and when the null hypothesis was the data is level.

The index data looks as follows:

```{r}

market_data |> plot_open_over_time()
```

### Transformation(s)

Index data is transformed to monthly annual overlapping investment returns. The benefit of this is the generation of extra data points. Given the limited history of cryptocurrency, this was an essential transformation. The downside to this approach would be any autocorrelation within our datasets.

We are completing our analysis on the excess-of-mean returns. To do this, we deducted the historical mean from our datasets, such that the mean of the simple returns is 0%. It should be noted that this was not a trivial amount for cryptocurrency.

In this analysis we have chosen to use log returns. This has the advantage of allowing returns to occupy a range between ±∞, unlike simple returns which can theoretically be below -100%. This is particularly useful for the incredibly volatile asset that is crypto-currency, where distribution fitting would likely extend beyond the -100% for non-trivial probabilities.

We then added in a risk premium to reflect the best estimate of expected returns for this asset class. When choosing a value it is worth considering what type of asset cryptocurrency is. If it is indeed a currency, then a risk premium of 0% would seem appropriate given currency is not a growth asset. However cryptocurrency appears to act more like a commodity that investors purchase in the hope that someone will pay more for it in the future. This is more akin to a bar of gold than a dollar.

Given the asset acts more like a commodity, we are assuming the expected return to be similar to expected inflation. At time of writing (May 2025) the inflation rate is high, however the Office for Budget Responsibility (OBR) has predicted from 2026 rates will be around 2%, with a range of around 0-5%. We have therefore set our risk premium to be 3%, closer to the current rate of inflation. \[https://obr.uk/efo/economic-and-fiscal-outlook-march-2025\]

It should be noted that when we combined these transformations, the mean of our datasets was very negative. For example the mean of log transformed BTC data, before adding any risk premium adjustments, was -58%. The reason is that the mean of a log returns dataset is lower than the mean of simple returns dataset by half of the variance of the simple returns. For most asset classes, this might not be an enormous number, but if cryptocurrency is anything, it’s a volatile asset. In the case of Bitcoin, the variance of the simple annualised returns was an enormous 106%, hence the very negative mean for the log transformed data.

### Annualised Change

We present the empirical data for our 4 chosen cryptocurrencies in the plots below. Firstly we show the time series of the annual log returns, as well as histograms of their distributions.

```{r}
#| label: annual change plot
#| echo: true

market_data |> plot_empirical_returns()

```

Perhaps the most striking things from the data are:

-   The annualised log changes are enormous. For comparison a similar distribution for UK Equities would be very rare to see a point beyond the ±50% range.

-   The 3 different cryptocurrencies are highly correlated in their movements. They almost move in complete synchronicity.

-   The distributions have quite negative means. This is a consequence of our data transformations. The mean of log returns is lower than the mean of simple returns, by an amount proportional to the variance. This amount can often be trivial, however as the variance in these distributions is huge, the mean of log returns is a lot lower than 0%.

## Distribution Fitting

We tried to fit a range of distributions to each one of our data sets. The distributions attempted (with the number of parameters in parentheses) are:

-   Normal (2)

-   Logistic (2)

-   Student T (3)

-   Hyperbolic (4)

We show the QQ plots for these fitting attempts below. We decided not to show the Student T as it typically converged to the Normal distribution and did not offer much alternative in terms of distribution choice.

```{r}
#| label: QQ plot
#| echo: false
#| out-width: "100%"

plot_data <- 
fitted_distributions |> 
  dplyr::select(-model) |> 
  dplyr::rename(data_quantiles = data) |> 
  tidyr::unnest(
    cols = c(data_quantiles, data_percentiles, fitted_quantiles)
  ) |> 
  dplyr::filter(distribution != "vg") |> 
  dplyr::mutate(
    distribution = names(distributions)[match(distribution, distributions)],
    distribution = factor(distribution, levels = names(distributions))
  )

plot_limits <- c(-5, 5)

plot_data |>
  ggplot() +
  aes(
    x = fitted_quantiles,
    y = data_quantiles,
    color = crypto
  ) +
  geom_abline(slope = 1, intercept = 0) +
  geom_point(shape = 1) +
  facet_grid(
    rows = vars(distribution),
    cols = vars(crypto)
  ) +
  scale_color_manual(values = crypto_colours) +
  scale_x_continuous(
    limits = plot_limits,
    name = "Fitted Quantiles",
    labels = scales::percent_format()
  ) +
  scale_y_continuous(
    limits = plot_limits,
    name = "Actual Quantiles",
    labels = scales::percent_format()
  ) +
  theme_bw() +
  theme(
    legend.position = "none",
    strip.background = element_rect(fill = "bisque1"),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
  ) 
  
```

From the QQ plot we can infer:

-   For BTC it is difficult to discern which distribution fits the best

-   For ETH it seems the Normal distribution fits best

-   For XRP it seems the Hyperbolic distribution fits best

Also helpful in determining the best fit are fitting statistics. We have calculated the following values:

-   Residual Sum of Squares (RSS) - this is the sum of least square values from our QQ plots. The lower the value, the better the fit.

-   Maximum Likelihood Estimator (MLE) - this is the likelihood of our empirical points upon our fitted distribution. The higher the value, the better the fit.

-   Akaike Information Criterion (AIC) - this is a fitting statistic based on the MLE. The lower the value, the better the fit.

-   Bayes Information Criterion (BIC) - similar to AIC, this statistic also penalises higher distributions with more parameters. The lower the value, the better the fit.

We present these in the tables below. To make deciphering easier, we have applied a colour scale over the table with redder values being poorer and whiter values being better fitting statistics:

:::{.panel-tabset}

```{r}
#| label: tables of fitting stats
#| echo: false  
#| results: asis
 
# code to be added
fitting_stats_df <-
fitted_distributions |> 
  dplyr::mutate(
    RSS = purrr::map2(
      data, 
      fitted_quantiles, 
      function(x, y) extract_rss(x, y)
      ) |> unlist(),
    LogLik = purrr::map(
      model, 
      function(x) extract_loglik(x)
      ) |> unlist(),
    AIC = purrr::map(
      model, 
      function(x) extract_aic(x)
      ) |> unlist(),
    BIC = purrr::map(
      model, 
      function(x) extract_bic(x)
      ) |> unlist()
  ) |> 
  dplyr::select(
    crypto, distribution, RSS, LogLik, AIC, BIC
  ) |> 
  dplyr::filter(distribution != "vg") |> 
  dplyr::mutate(
    distribution = names(distributions)[match(distribution, distributions)],
    distribution = factor(distribution, levels = names(distributions))
  ) |> 
  dplyr::rename(Distribution = distribution)


gt_theme <- function(gt) {
  
  gt |> 
      gt::cols_align(columns = dplyr::where(is.numeric), align = "center") |> 
  gt::tab_options(
        column_labels.background.color = "#008CBA",
        quarto.disable_processing = TRUE
        ) |>
  gt::opt_vertical_padding(scale = 0.8)
}


format_fitting_stats_df <- function(df) {
  df |> 
  gt::gt() |> 
  gt::fmt_number(columns = "RSS", decimals = 3) |> 
  gt::fmt_number(columns = c("LogLik", "AIC", "BIC"), decimals = 1) |> 
  gt::data_color(
    columns = dplyr::where(is.numeric),
    colors = function(x) {
      abs_x <- abs(x)
      scales::col_numeric(
        palette = "Oranges",
        domain = range(abs_x, na.rm = TRUE)
      )(abs_x)
    },
    apply_to = "fill",
    autocolor_text = TRUE
  ) |> 
  gt::cols_width(dplyr::where(is.numeric) ~ gt::px(90),
                 "Distribution" ~ gt::px(160)) |> 
    gt_theme()

}

fitting_stats_list <-
fitting_stats_df |> 
  dplyr::arrange(crypto) |> 
  dplyr::group_split(crypto, .keep = FALSE) |> purrr::set_names(fitting_stats_df$crypto |> levels()) |> 
  purrr::map(format_fitting_stats_df)

fitting_stats_list |> create_tabset_for_render()

```

:::



```{r}
#| label: final distributions
#| echo: false  
 
# code to be added

sample_percentiles <- c(0.995, 0.975, 0.9, 0.5, 0.1, 0.025, 0.005)

sample_distributions <-
fitted_distributions |> 
  dplyr::filter(distribution == "hyperb") |> 
  dplyr::mutate(sample_percentiles = list(sample_percentiles)) |> 
  dplyr::mutate(
    sample_quantiles = purrr::map2(
      .x = distribution,
      .y = model,
      .f = function(x, y) {
        extract_fit_quantiles(
          x,
          y,
          percentiles = .env$sample_percentiles)
      })
  )

key_percentiles_df <-
sample_distributions |> 
  dplyr::select(crypto, sample_percentiles, sample_quantiles) |> 
  tidyr::unnest(cols = c("sample_percentiles", "sample_quantiles")) |> 
  dplyr::mutate(sample_quantiles = exp(sample_quantiles) - 1) |> 
  tidyr::pivot_wider(names_from = crypto, values_from = sample_quantiles) |> 
  dplyr::arrange(desc(sample_percentiles)) |> 
  dplyr::rename(Percentile = sample_percentiles) 

key_percentiles_gt <-
  key_percentiles_df |> 
  gt::gt() |> 
  gt::fmt_percent(columns = -"Percentile", decimals = 1, force_sign = TRUE) |> 
  gt::fmt_percent(columns = "Percentile", decimals = 1) |> 
  gt_theme()

```

